#!/usr/bin/env ruby

require 'bundler/setup'
require 'vic20'

require 'pry'

require 'optparse'
require 'scanf'

$options = {}

OptionParser.new do |opts|
  opts.banner = 'Usage: run [options] [firmware]'

  opts.on('-r', '--reset address', 'override reset vector') do |address, *|
    $options[:reset] = address.to_i(16)
  end

  opts.on('-v', '--verbose', 'turn on verbose mode') do |v|
    $options[:verbose] = v
  end
end.parse!

memory = Vic20::Memory.new(ARGV[0])
processor = Vic20::Processor.new(memory)

processor.reset($options[:reset])

commands = Pry::CommandSet.new do
  import_from Pry::Commands, 'help'

  create_command 'breakpoint' do
    group 'Machine'
    description 'Set breakpoint at specified address.'

    def process
      $options[:breakpoints] ||= []

      $options[:breakpoints] << args.first.to_i(16) if args.first

      $options[:breakpoints].each_with_index do |address, index|
        output.puts "#{index + 1}: $#{address.to_s(16).rjust(4, '0')}"
      end
    end
  end

  alias_command 'b', 'breakpoint'

  create_command 'dasm' do
    group 'Machine'
    description 'Disassemble instructions at current program counter.'

    def process
      initial_pc = processor.pc

      _pry_.pager.open do |output|
        processor.each do |address, method, addressing_mode, bytes|
          output.puts format_instruction(address, method, addressing_mode, bytes)
        end
      end

    ensure
      processor.pc = initial_pc
    end
  end

  alias_command 'd', 'dasm'

  create_command 'list' do
    group 'Machine'
    description 'List memory contents'

    def process
      address = args.first ? args.first.to_i(16) : processor.pc

      _pry_.pager.open do |output|
        memory[address..-1].each_slice(16) do |slice|
          output.puts format_memory(address, slice)
          address += 16
        end
      end
    end
  end

  alias_command 'l', 'list'

  create_command 'run' do
    group 'Machine'
    description 'Run program from current program counter.'

    def process
      processor.each do |address, method, addressing_mode, bytes|
        begin
          processor.send(method, addressing_mode, bytes)
          raise Vic20::Processor::Trap if processor.pc == address
        rescue
          STDERR.puts format_instruction(address, method, addressing_mode, bytes)
          processor.pc = address
          raise
        end
        raise Vic20::Processor::Trap if $options[:breakpoints].include?(processor.pc)
      end
    end
  end

  alias_command 'r', 'run'

  create_command 'step' do
    group 'Machine'
    description 'Execute single instruction at current program counter.'

    def process
      initial_pc = processor.pc

      address, method, addressing_mode, bytes = processor.each.next
      output.puts format_instruction(address, method, addressing_mode, bytes)
      processor.send(method, addressing_mode, bytes)

    rescue
      processor.pc = initial_pc
      raise
    end
  end

  alias_command 's', 'step'

  helpers do
    def format_assembly(method, addressing_mode, bytes)
      "; #{method.upcase} #{Vic20::Processor.format_operand(addressing_mode, bytes)}"
    end

    def format_instruction(address, method, addressing_mode, bytes)
      [
        format('%04X', address),
        bytes.map { |byte| format('%02X', byte) }.join(' ').ljust(8, ' '),
        format_assembly(method, addressing_mode, bytes),
      ].join('  ')
    end

    def format_memory(address, bytes)
      [
        format('%04X', address),
        bytes.map { |byte| format('%02X', byte) }.join(' '),
        bytes.pack('c*').gsub(/[^[:print:]]/, '.'),
      ].join('  ')
    end

    def memory
      processor.instance_variable_get :@memory
    end

    def processor
      target_self
    end
  end
end

processor.pry commands: commands, prompt: [proc { "#{processor.current_state} > " }, proc { ' | ' }]
